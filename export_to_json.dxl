// ============================================================================
// DOORS to JSON Export Script
// ============================================================================
// Purpose: Export DOORS module and linked modules to JSON format
// Usage: Run in batch mode with module path as argument
// Output: output.json in script directory
// ============================================================================

pragma runLim, 0  // Disable execution timeout

// ----------------------------------------------------------------------------
// GLOBAL CONFIGURATION - EDIT THESE VALUES
// ----------------------------------------------------------------------------
int MAX_DEPTH
string OUTPUT_FILE
string ROOT_MODULE_PATH  // Set this to your module path before running

// ----------------------------------------------------------------------------
// GLOBAL VARIABLES
// ----------------------------------------------------------------------------
Skip visitedModules
Buffer jsonOutput
int totalObjects
int totalModules
Skip linkedModuleQueue

// Initialize globals - EDIT ROOT_MODULE_PATH before running
MAX_DEPTH = 2  // Original module (0) + 1 level of linked modules (1)
OUTPUT_FILE = "output.json"
ROOT_MODULE_PATH = "/ProjectA/HLR"  // <-- CHANGE THIS to your module path

visitedModules = create()  // Track visited modules to prevent duplicates
jsonOutput = create()      // Main JSON output buffer
totalObjects = 0           // Counter for total objects processed
totalModules = 0           // Counter for total modules processed
linkedModuleQueue = create()  // Queue of linked modules to process

// ----------------------------------------------------------------------------
// UTILITY FUNCTIONS
// ----------------------------------------------------------------------------

// Escape special characters for JSON string values
string escapeJSON(string value) {
    Buffer buf
    int len
    int i
    string c
    string result

    if (null value) return ""

    buf = create()
    len = length(value)

    for (i = 0; i < len; i++) {
        c = value[i:i]

        if (c == "\\") {
            buf += "\\\\"
        } else if (c == "\"") {
            buf += "\\\""
        } else if (c == "\n") {
            buf += "\\n"
        } else if (c == "\r") {
            buf += "\\r"
        } else if (c == "\t") {
            buf += "\\t"
        } else {
            buf += c
        }
    }

    result = tempStringOf(buf)
    delete(buf)
    return result
}

// Get indentation string
string getIndent(int level) {
    Buffer buf
    int i
    string result

    buf = create()
    for (i = 0; i < level; i++) {
        buf += "  "
    }
    result = tempStringOf(buf)
    delete(buf)
    return result
}

// Convert date to ISO string
string dateToISO(string dateStr) {
    if (null dateStr || dateStr == "") return ""
    return escapeJSON(dateStr)
}

// ----------------------------------------------------------------------------
// LINK PROCESSING FUNCTIONS
// ----------------------------------------------------------------------------

// Extract links from an object and add to JSON buffer
void extractLinks(Object obj, Buffer linkBuf, int indent, int currentDepth) {
    bool hasLinks
    bool firstLink
    Link lnk
    Object targetObj
    Object sourceObj
    Module targetMod
    Module sourceMod
    string targetModPath
    string sourceModPath
    string linkModName
    string currentModPath

    hasLinks = false
    firstLink = true

    linkBuf += getIndent(indent) "\"links\": [\n"

    // Process outgoing links
    for lnk in obj -> "*" do {
        if (!hasLinks) hasLinks = true
        if (!firstLink) linkBuf += ",\n"
        firstLink = false

        targetObj = target(lnk)
        targetMod = module(targetObj)
        targetModPath = fullName(targetMod)
        linkModName = name(module(lnk))

        linkBuf += getIndent(indent + 1) "{\n"
        linkBuf += getIndent(indent + 2) "\"type\": \"" escapeJSON(linkModName) "\",\n"
        linkBuf += getIndent(indent + 2) "\"direction\": \"outgoing\",\n"
        linkBuf += getIndent(indent + 2) "\"targetModule\": \"" escapeJSON(targetModPath) "\",\n"
        linkBuf += getIndent(indent + 2) "\"targetObjectId\": \"" escapeJSON(identifier(targetObj)) "\"\n"
        linkBuf += getIndent(indent + 1) "}"

        // Queue target module if it's different and within depth limit
        if (currentDepth < MAX_DEPTH - 1) {
            currentModPath = fullName(module(obj))
            if (targetModPath != currentModPath && !find(visitedModules, targetModPath)) {
                put(linkedModuleQueue, targetModPath, currentDepth + 1)
            }
        }
    }

    // Process incoming links
    for lnk in obj <- "*" do {
        if (!hasLinks) hasLinks = true
        if (!firstLink) linkBuf += ",\n"
        firstLink = false

        sourceObj = source(lnk)
        sourceMod = module(sourceObj)
        sourceModPath = fullName(sourceMod)
        linkModName = name(module(lnk))

        linkBuf += getIndent(indent + 1) "{\n"
        linkBuf += getIndent(indent + 2) "\"type\": \"" escapeJSON(linkModName) "\",\n"
        linkBuf += getIndent(indent + 2) "\"direction\": \"incoming\",\n"
        linkBuf += getIndent(indent + 2) "\"sourceModule\": \"" escapeJSON(sourceModPath) "\",\n"
        linkBuf += getIndent(indent + 2) "\"sourceObjectId\": \"" escapeJSON(identifier(sourceObj)) "\"\n"
        linkBuf += getIndent(indent + 1) "}"

        // Queue source module if it's different and within depth limit
        if (currentDepth < MAX_DEPTH - 1) {
            currentModPath = fullName(module(obj))
            if (sourceModPath != currentModPath && !find(visitedModules, sourceModPath)) {
                put(linkedModuleQueue, sourceModPath, currentDepth + 1)
            }
        }
    }

    linkBuf += "\n" getIndent(indent) "]"
}

// ----------------------------------------------------------------------------
// ATTRIBUTE EXTRACTION FUNCTIONS
// ----------------------------------------------------------------------------

// Extract all non-empty attributes from an object
void extractAttributes(Object obj, Buffer attrBuf, int indent) {
    Module m
    AttrDef ad
    string attrName
    string attrTypeName
    string value
    int iValue
    real rValue
    Date dValue
    bool bValue
    string bStr

    m = module(obj)

    for ad in m do {
        attrName = ad.name
        attrTypeName = ad.typeName

        // Get attribute value based on type
        if (attrTypeName == "Text" || attrTypeName == "String" || attrTypeName == "RichText") {
            value = obj.(attrName)
            if (!null value && value != "") {
                attrBuf += ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": \"" escapeJSON(value) "\""
            }
        } else if (attrTypeName == "Integer") {
            iValue = obj.(attrName)
            if (!null iValue) {
                attrBuf += ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": " iValue ""
            }
        } else if (attrTypeName == "Real") {
            rValue = obj.(attrName)
            if (!null rValue) {
                attrBuf += ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": " rValue ""
            }
        } else if (attrTypeName == "Date") {
            dValue = obj.(attrName)
            if (!null dValue) {
                attrBuf += ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": \"" dateToISO(dateAndTime(dValue)) "\""
            }
        } else if (attrTypeName == "Boolean") {
            bValue = obj.(attrName)
            if (!null bValue) {
                if (bValue) {
                    bStr = "true"
                } else {
                    bStr = "false"
                }
                attrBuf += ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": " bStr ""
            }
        }
    }
}

// ----------------------------------------------------------------------------
// OBJECT PROCESSING FUNCTIONS
// ----------------------------------------------------------------------------

// Forward declaration
void processObjectRecursive(Object obj, Buffer objBuf, int indent, int currentDepth, bool isFirst)

// Process children of an object
void processChildren(Object parentObj, Buffer childBuf, int indent, int currentDepth) {
    Object childObj
    bool hasChildren
    bool firstChild

    hasChildren = false
    firstChild = true

    childBuf += getIndent(indent) "\"children\": [\n"

    for childObj in parentObj do {
        hasChildren = true
        processObjectRecursive(childObj, childBuf, indent + 1, currentDepth, firstChild)
        firstChild = false
    }

    childBuf += "\n" getIndent(indent) "]"
}

// Process a single object recursively
void processObjectRecursive(Object obj, Buffer objBuf, int indent, int currentDepth, bool isFirst) {
    Buffer attrBuf
    Buffer linkBuf
    Buffer childBuf
    Object childObj
    bool hasChildren

    if (!isFirst) {
        objBuf += ",\n"
    }

    totalObjects++

    objBuf += getIndent(indent) "{\n"

    // Basic object information
    objBuf += getIndent(indent + 1) "\"id\": \"" escapeJSON(identifier(obj)) "\""
    objBuf += ",\n" getIndent(indent + 1) "\"level\": " level(obj) ""
    objBuf += ",\n" getIndent(indent + 1) "\"absoluteNumber\": \"" escapeJSON(obj."Absolute Number" "") "\""

    // Extract all attributes
    attrBuf = create()
    extractAttributes(obj, attrBuf, indent + 1)
    objBuf += tempStringOf(attrBuf)
    delete(attrBuf)

    // Extract links
    objBuf += ",\n"
    linkBuf = create()
    extractLinks(obj, linkBuf, indent + 1, currentDepth)
    objBuf += tempStringOf(linkBuf)
    delete(linkBuf)

    // Process children
    hasChildren = false
    for childObj in obj do {
        hasChildren = true
        break
    }

    if (hasChildren) {
        objBuf += ",\n"
        childBuf = create()
        processChildren(obj, childBuf, indent + 1, currentDepth)
        objBuf += tempStringOf(childBuf)
        delete(childBuf)
    }

    objBuf += "\n" getIndent(indent) "}"
}

// ----------------------------------------------------------------------------
// MODULE PROCESSING FUNCTIONS
// ----------------------------------------------------------------------------

// Process a single module and all its objects
void processModule(string modulePath, int depth, Buffer modBuf, bool isFirst) {
    Module mod
    Object obj
    bool firstObj

    // Check if already visited
    if (find(visitedModules, modulePath)) {
        print "  Skipping already visited module: " modulePath "\n"
        return
    }

    print "Processing module (depth " depth "): " modulePath "\n"

    // Mark as visited
    put(visitedModules, modulePath, depth)
    totalModules++

    // Open module
    mod = read(modulePath, false)
    if (null mod) {
        print "  ERROR: Cannot open module: " modulePath "\n"
        return
    }

    if (!isFirst) {
        modBuf += ",\n"
    }

    modBuf += getIndent(2) "{\n"
    modBuf += getIndent(3) "\"modulePath\": \"" escapeJSON(modulePath) "\",\n"
    modBuf += getIndent(3) "\"moduleName\": \"" escapeJSON(name(mod)) "\",\n"
    modBuf += getIndent(3) "\"depth\": " depth ",\n"
    modBuf += getIndent(3) "\"objects\": [\n"

    // Process all objects at root level
    firstObj = true
    for obj in entire mod do {
        if (level(obj) == 1) {  // Only process top-level objects
            processObjectRecursive(obj, modBuf, 4, depth, firstObj)
            firstObj = false
        }
    }

    modBuf += "\n" getIndent(3) "]\n"
    modBuf += getIndent(2) "}"

    close(mod)
    print "  Completed module: " modulePath " (depth " depth ")\n"
}

// ----------------------------------------------------------------------------
// MAIN EXPORT FUNCTION
// ----------------------------------------------------------------------------

void exportToJSON(string rootModulePath) {
    string exportDate
    Buffer moduleBuf
    string linkedPath
    int linkedDepth
    bool firstLinked
    Stream outFile

    print "\n===========================================\n"
    print "DOORS to JSON Export\n"
    print "===========================================\n"
    print "Root module: " rootModulePath "\n"
    print "Max depth: " MAX_DEPTH "\n"
    print "Output file: " OUTPUT_FILE "\n"
    print "===========================================\n\n"

    // Get current date/time
    exportDate = dateAndTime(today)

    // Start JSON structure
    jsonOutput += "{\n"
    jsonOutput += getIndent(1) "\"exportDate\": \"" escapeJSON(exportDate) "\",\n"
    jsonOutput += getIndent(1) "\"rootModule\": \"" escapeJSON(rootModulePath) "\",\n"
    jsonOutput += getIndent(1) "\"maxDepth\": " MAX_DEPTH ",\n"
    jsonOutput += getIndent(1) "\"modules\": [\n"

    // Process root module
    moduleBuf = create()
    processModule(rootModulePath, 0, moduleBuf, true)

    // Process linked modules from queue
    firstLinked = false

    for linkedPath in linkedModuleQueue do {
        if (find(linkedModuleQueue, linkedPath, linkedDepth)) {
            if (linkedDepth < MAX_DEPTH) {
                processModule(linkedPath, linkedDepth, moduleBuf, firstLinked)
                firstLinked = false
            }
        }
    }

    jsonOutput += tempStringOf(moduleBuf)
    delete(moduleBuf)

    // Close JSON structure
    jsonOutput += "\n" getIndent(1) "]\n"
    jsonOutput += "}\n"

    // Write to file
    print "\n===========================================\n"
    print "Writing output to file...\n"

    outFile = write(OUTPUT_FILE)
    if (null outFile) {
        print "ERROR: Cannot create output file: " OUTPUT_FILE "\n"
        return
    }

    outFile << tempStringOf(jsonOutput)
    close(outFile)

    print "===========================================\n"
    print "Export completed successfully!\n"
    print "===========================================\n"
    print "Total modules processed: " totalModules "\n"
    print "Total objects processed: " totalObjects "\n"
    print "Output file: " OUTPUT_FILE "\n"
    print "===========================================\n\n"
}

// ----------------------------------------------------------------------------
// MAIN SCRIPT ENTRY POINT
// ----------------------------------------------------------------------------

// Check if module path is configured
if (null ROOT_MODULE_PATH || ROOT_MODULE_PATH == "") {
    print "\n"
    print "===========================================\n"
    print "DOORS to JSON Export Script\n"
    print "===========================================\n"
    print "ERROR: ROOT_MODULE_PATH is not set!\n"
    print "\n"
    print "Please edit the script and set ROOT_MODULE_PATH\n"
    print "at line 30 to your module path.\n"
    print "\n"
    print "Example:\n"
    print "  ROOT_MODULE_PATH = \"/Project/Requirements\"\n"
    print "===========================================\n\n"
    halt
}

// Run the export
exportToJSON(ROOT_MODULE_PATH)

// Cleanup
delete(visitedModules)
delete(linkedModuleQueue)
delete(jsonOutput)
