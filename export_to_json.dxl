// ============================================================================
// DOORS to JSON Export Script
// ============================================================================
// Purpose: Export DOORS module and linked modules to JSON format
// Usage: Run in batch mode with module path as argument
// Output: output.json in script directory
// ============================================================================

pragma runLim, 0  // Disable execution timeout

// ----------------------------------------------------------------------------
// GLOBAL CONFIGURATION - EDIT THESE VALUES
// ----------------------------------------------------------------------------
int MAX_DEPTH
string OUTPUT_FILE
string ROOT_MODULE_PATH  // Set this to your module path before running

// ----------------------------------------------------------------------------
// GLOBAL VARIABLES
// ----------------------------------------------------------------------------
Skip visitedModules
Stream outFile              // Output file stream for direct writing
int totalObjects
int totalModules
Skip linkedModuleQueue

// Initialize globals - EDIT ROOT_MODULE_PATH before running
MAX_DEPTH = 2  // Original module (0) + 1 level of linked modules (1)
OUTPUT_FILE = "output.json"
ROOT_MODULE_PATH = "/ProjectA/HLR"  // <-- CHANGE THIS to your module path

visitedModules = create()  // Track visited modules to prevent duplicates
outFile = null             // Will be opened at export start
totalObjects = 0           // Counter for total objects processed
totalModules = 0           // Counter for total modules processed
linkedModuleQueue = create()  // Queue of linked modules to process

// ----------------------------------------------------------------------------
// UTILITY FUNCTIONS
// ----------------------------------------------------------------------------

// Escape special characters for JSON string values
string escapeJSON(string value) {
    Buffer buf
    int len
    int i
    string c
    string result

    if (null value) return ""

    buf = create()
    len = length(value)

    for (i = 0; i < len; i++) {
        c = value[i:i]

        if (c == "\\") {
            buf += "\\\\"
        } else if (c == "\"") {
            buf += "\\\""
        } else if (c == "\n") {
            buf += "\\n"
        } else if (c == "\r") {
            buf += "\\r"
        } else if (c == "\t") {
            buf += "\\t"
        } else {
            buf += c
        }
    }

    result = tempStringOf(buf)
    delete(buf)
    return result
}

// Get indentation string
string getIndent(int level) {
    Buffer buf
    int i
    string result

    buf = create()
    for (i = 0; i < level; i++) {
        buf += "  "
    }
    result = tempStringOf(buf)
    delete(buf)
    return result
}

// Convert date to ISO string
string dateToISO(string dateStr) {
    if (null dateStr || dateStr == "") return ""
    return escapeJSON(dateStr)
}

// ----------------------------------------------------------------------------
// LINK PROCESSING FUNCTIONS
// ----------------------------------------------------------------------------

// Extract links from an object and write directly to output stream
void extractLinks(Object obj, int indent, int currentDepth) {
    bool firstLink
    Link lnk
    Object targetObj
    Object sourceObj
    Module targetMod
    Module sourceMod
    string targetModPath
    string sourceModPath
    string linkModName
    string currentModPath

    firstLink = true

    outFile << getIndent(indent) "\"links\": [\n"

    // Process outgoing links
    for lnk in obj -> "*" do {
        if (!firstLink) outFile << ",\n"
        firstLink = false

        targetObj = target(lnk)
        targetMod = module(targetObj)
        targetModPath = fullName(targetMod)
        linkModName = name(module(lnk))

        outFile << getIndent(indent + 1) "{\n"
        outFile << getIndent(indent + 2) "\"type\": \"" escapeJSON(linkModName) "\",\n"
        outFile << getIndent(indent + 2) "\"direction\": \"outgoing\",\n"
        outFile << getIndent(indent + 2) "\"targetModule\": \"" escapeJSON(targetModPath) "\",\n"
        outFile << getIndent(indent + 2) "\"targetObjectId\": \"" escapeJSON(identifier(targetObj)) "\"\n"
        outFile << getIndent(indent + 1) "}"

        // Queue target module if it's different and within depth limit
        if (currentDepth < MAX_DEPTH - 1) {
            currentModPath = fullName(module(obj))
            if (targetModPath != currentModPath && !find(visitedModules, targetModPath)) {
                put(linkedModuleQueue, targetModPath, currentDepth + 1)
            }
        }
    }

    // Process incoming links
    for lnk in obj <- "*" do {
        if (!firstLink) outFile << ",\n"
        firstLink = false

        sourceObj = source(lnk)
        sourceMod = module(sourceObj)
        sourceModPath = fullName(sourceMod)
        linkModName = name(module(lnk))

        outFile << getIndent(indent + 1) "{\n"
        outFile << getIndent(indent + 2) "\"type\": \"" escapeJSON(linkModName) "\",\n"
        outFile << getIndent(indent + 2) "\"direction\": \"incoming\",\n"
        outFile << getIndent(indent + 2) "\"sourceModule\": \"" escapeJSON(sourceModPath) "\",\n"
        outFile << getIndent(indent + 2) "\"sourceObjectId\": \"" escapeJSON(identifier(sourceObj)) "\"\n"
        outFile << getIndent(indent + 1) "}"

        // Queue source module if it's different and within depth limit
        if (currentDepth < MAX_DEPTH - 1) {
            currentModPath = fullName(module(obj))
            if (sourceModPath != currentModPath && !find(visitedModules, sourceModPath)) {
                put(linkedModuleQueue, sourceModPath, currentDepth + 1)
            }
        }
    }

    outFile << "\n" getIndent(indent) "]"
}

// ----------------------------------------------------------------------------
// ATTRIBUTE EXTRACTION FUNCTIONS
// ----------------------------------------------------------------------------

// Extract all non-empty attributes from an object and write directly to stream
void extractAttributes(Object obj, int indent) {
    Module m
    AttrDef ad
    string attrName
    string attrTypeName
    string value
    int iValue
    real rValue
    Date dValue
    bool bValue
    string bStr

    m = module(obj)

    for ad in m do {
        attrName = ad.name
        attrTypeName = ad.typeName

        // Skip Description attribute which may not be accessible on all objects
        if (attrName == "Description") continue

        // Use error suppression to handle inaccessible attributes
        noError

        // Get attribute value based on type
        if (attrTypeName == "Text" || attrTypeName == "String" || attrTypeName == "RichText") {
            value = obj.(attrName)
            if (lastError() == "" && !null value && value != "") {
                outFile << ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": \"" escapeJSON(value) "\""
            }
        } else if (attrTypeName == "Integer") {
            iValue = obj.(attrName)
            if (lastError() == "" && !null iValue) {
                outFile << ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": " iValue ""
            }
        } else if (attrTypeName == "Real") {
            rValue = obj.(attrName)
            if (lastError() == "" && !null rValue) {
                outFile << ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": " rValue ""
            }
        } else if (attrTypeName == "Date") {
            dValue = obj.(attrName)
            if (lastError() == "" && !null dValue) {
                outFile << ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": \"" dateToISO(dateAndTime(dValue)) "\""
            }
        } else if (attrTypeName == "Boolean") {
            bValue = obj.(attrName)
            if (lastError() == "" && !null bValue) {
                if (bValue) {
                    bStr = "true"
                } else {
                    bStr = "false"
                }
                outFile << ",\n" getIndent(indent) "\"" escapeJSON(attrName) "\": " bStr ""
            }
        }

        // Clear any errors and restore error handling
        lastError()
    }
}

// ----------------------------------------------------------------------------
// OBJECT PROCESSING FUNCTIONS
// ----------------------------------------------------------------------------

// Process all objects in a module as a flat array - writes directly to stream
void processAllObjects(Module mod, int indent, int currentDepth) {
    Object obj
    bool firstObj
    int objLevel

    firstObj = true

    for obj in entire mod do {
        // Skip deleted objects
        if (isDeleted(obj)) continue

        if (!firstObj) {
            outFile << ",\n"
        }
        firstObj = false

        totalObjects++
        objLevel = level(obj)

        outFile << getIndent(indent) "{\n"

        // Basic object information
        outFile << getIndent(indent + 1) "\"id\": \"" escapeJSON(identifier(obj)) "\""
        outFile << ",\n" getIndent(indent + 1) "\"level\": " objLevel ""
        outFile << ",\n" getIndent(indent + 1) "\"absoluteNumber\": \"" escapeJSON(obj."Absolute Number" "") "\""

        // Extract all attributes - writes directly to stream
        extractAttributes(obj, indent + 1)

        // Extract links - writes directly to stream
        outFile << ",\n"
        extractLinks(obj, indent + 1, currentDepth)

        outFile << "\n" getIndent(indent) "}"
    }
}

// ----------------------------------------------------------------------------
// MODULE PROCESSING FUNCTIONS
// ----------------------------------------------------------------------------

// Process a single module and all its objects - writes directly to stream
void processModule(string modulePath, int depth, bool isFirst) {
    Module mod

    // Check if already visited
    if (find(visitedModules, modulePath)) {
        print "  Skipping already visited module: " modulePath "\n"
        return
    }

    print "Processing module (depth " depth "): " modulePath "\n"

    // Mark as visited
    put(visitedModules, modulePath, depth)
    totalModules++

    // Open module
    mod = read(modulePath, false)
    if (null mod) {
        print "  ERROR: Cannot open module: " modulePath "\n"
        return
    }

    if (!isFirst) {
        outFile << ",\n"
    }

    outFile << getIndent(2) "{\n"
    outFile << getIndent(3) "\"modulePath\": \"" escapeJSON(modulePath) "\",\n"
    outFile << getIndent(3) "\"moduleName\": \"" escapeJSON(name(mod)) "\",\n"
    outFile << getIndent(3) "\"depth\": " depth ",\n"
    outFile << getIndent(3) "\"objects\": [\n"

    // Process all objects iteratively - writes directly to stream
    processAllObjects(mod, 4, depth)

    outFile << "\n" getIndent(3) "]\n"
    outFile << getIndent(2) "}"

    close(mod)
    print "  Completed module: " modulePath " (depth " depth ")\n"
}

// ----------------------------------------------------------------------------
// MAIN EXPORT FUNCTION
// ----------------------------------------------------------------------------

void exportToJSON(string rootModulePath) {
    string exportDate
    string linkedPath
    int linkedDepth
    bool firstLinked

    print "\n===========================================\n"
    print "DOORS to JSON Export (Streaming Mode)\n"
    print "===========================================\n"
    print "Root module: " rootModulePath "\n"
    print "Max depth: " MAX_DEPTH "\n"
    print "Output file: " OUTPUT_FILE "\n"
    print "===========================================\n\n"

    // Open output file FIRST - all writes go directly to file
    print "Opening output file for streaming...\n"
    outFile = write(OUTPUT_FILE)
    if (null outFile) {
        print "ERROR: Cannot create output file: " OUTPUT_FILE "\n"
        return
    }

    // Get current date/time
    exportDate = dateAndTime(today())

    // Write JSON header directly to file
    outFile << "{\n"
    outFile << getIndent(1) "\"exportDate\": \"" escapeJSON(exportDate) "\",\n"
    outFile << getIndent(1) "\"rootModule\": \"" escapeJSON(rootModulePath) "\",\n"
    outFile << getIndent(1) "\"maxDepth\": " MAX_DEPTH ",\n"
    outFile << getIndent(1) "\"modules\": [\n"

    // Process root module - writes directly to file
    processModule(rootModulePath, 0, true)

    // Process linked modules from queue
    firstLinked = false

    for linkedPath in linkedModuleQueue do {
        if (find(linkedModuleQueue, linkedPath, linkedDepth)) {
            if (linkedDepth < MAX_DEPTH) {
                processModule(linkedPath, linkedDepth, firstLinked)
                firstLinked = false
            }
        }
    }

    // Close JSON structure
    outFile << "\n" getIndent(1) "]\n"
    outFile << "}\n"

    // Close output file
    close(outFile)

    print "\n===========================================\n"
    print "Export completed successfully!\n"
    print "===========================================\n"
    print "Total modules processed: " totalModules "\n"
    print "Total objects processed: " totalObjects "\n"
    print "Output file: " OUTPUT_FILE "\n"
    print "===========================================\n\n"
}

// ----------------------------------------------------------------------------
// MAIN SCRIPT ENTRY POINT
// ----------------------------------------------------------------------------

// Check if module path is configured
if (null ROOT_MODULE_PATH || ROOT_MODULE_PATH == "") {
    print "\n"
    print "===========================================\n"
    print "DOORS to JSON Export Script\n"
    print "===========================================\n"
    print "ERROR: ROOT_MODULE_PATH is not set!\n"
    print "\n"
    print "Please edit the script and set ROOT_MODULE_PATH\n"
    print "at line 30 to your module path.\n"
    print "\n"
    print "Example:\n"
    print "  ROOT_MODULE_PATH = \"/Project/Requirements\"\n"
    print "===========================================\n\n"
    halt
}

// Run the export
exportToJSON(ROOT_MODULE_PATH)

// Cleanup
delete(visitedModules)
delete(linkedModuleQueue)
